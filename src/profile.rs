use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufWriter, Write};
use std::path::PathBuf;
use std::time::SystemTime;

use chrono::prelude::*;
use miette::{IntoDiagnostic, Result};
use owo_colors::OwoColorize;

static ORDER_FILE: &str = "modlist.txt";
static DRYRUN_FILE: &str = "modlist_synced_dryrun.txt";
static PRELUDE: &str = "# This file was automatically generated by Mod Organizer.";

pub enum Status {
    Core,
    Enabled,
    Disabled,
}

impl std::fmt::Display for Status {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Status::Core => write!(f, "*"),
            Status::Enabled => write!(f, "+"),
            Status::Disabled => write!(f, "-"),
        }
    }
}

impl From<&str> for Status {
    fn from(v: &str) -> Self {
        if v == "*" {
            Status::Core
        } else if v == "+" {
            Status::Enabled
        } else {
            Status::Disabled
        }
    }
}

/// A representation of a specific profile, recording which mods are mentioned,
/// which are enabled, which are disabled, and what order they're in.
pub struct Profile {
    name: String,
    path: PathBuf,
    priorities: Vec<String>,
    statuses: HashMap<String, Status>,
    modified: SystemTime,
}

impl Profile {
    pub fn from_path(mut path: PathBuf) -> Result<Self> {
        let name = path
            .components()
            .rev()
            .take(1)
            .collect::<PathBuf>()
            .display()
            .to_string();
        path.push(ORDER_FILE);

        let mut statuses = HashMap::new();
        let mut priorities = Vec::new();

        let metadata = std::fs::metadata(&path).into_diagnostic()?;
        let modified = metadata.modified().into_diagnostic()?;
        let file = File::open(&path).into_diagnostic()?;
        let reader = std::io::BufReader::new(file).lines();
        for line in reader.flatten() {
            if line == PRELUDE {
                continue;
            }
            if line.len() < 2 {
                // TODO should be error. We need the enabled signal followed by a mod name.
                continue;
            }
            let (prefix, modname) = line.split_at(1);
            priorities.push(modname.to_string());
            statuses.insert(modname.to_string(), prefix.into());
        }

        let profile = Self {
            name,
            path,
            priorities,
            statuses,
            modified,
        };
        Ok(profile)
    }

    pub fn new(fullpath: &str) -> Result<Self> {
        Profile::from_path(fullpath.into())
    }

    pub fn name(&self) -> &str {
        self.name.as_str()
    }

    pub fn modified(&self) -> SystemTime {
        self.modified
    }

    pub fn modified_human(&self) -> String {
        let dt: DateTime<Local> = self.modified.into();
        chrono_humanize::HumanTime::from(dt).to_string()
    }

    pub fn len(&self) -> usize {
        self.priorities.len()
    }

    pub fn is_empty(&self) -> bool {
        self.priorities.is_empty()
    }

    pub fn mod_status(&self, modname: &str) -> &Status {
        // TODO This is exactly where you would put any attempts to figure out if
        // a mod has been renamed by looking it up in a saved data store of
        // mod names to `modid` or something else in the meta.ini file.
        self.statuses.get(modname).unwrap_or(&Status::Disabled)
    }

    pub fn report(&self) {
        let enabled_count = self.statuses.iter().fold(0, |val, (_k, status)| {
            if matches!(status, Status::Enabled) {
                val + 1
            } else {
                val
            }
        });

        println!(
            "      mods: {}\n   enabled: {}\n  modified: {}",
            self.len().bold(),
            enabled_count.bold(),
            self.modified_human().bold()
        );
    }

    pub fn synchronize(&mut self, source: &Profile) {
        self.priorities = source.priorities.clone();
    }

    pub fn write(&self, dry_run: bool) -> Result<()> {
        let tmpfile = tempfile::NamedTempFile::new().into_diagnostic()?;
        {
            let mut fp = BufWriter::new(&tmpfile);
            write!(fp, "{PRELUDE}\r\n").into_diagnostic()?;
            for modname in self.priorities.as_slice() {
                write!(fp, "{}{}\r\n", self.mod_status(modname), modname).into_diagnostic()?;
            }
            fp.flush().into_diagnostic()?;
        }
        let tmppath = tmpfile.into_temp_path();

        if dry_run {
            let mut dry_run_path = self.path.clone();
            dry_run_path.set_file_name(DRYRUN_FILE);
            std::fs::copy(tmppath, &dry_run_path).into_diagnostic()?;
            println!(
                "{} order updated in {}",
                self.name().bold().blue(),
                DRYRUN_FILE.bold()
            );
        } else {
            let now: DateTime<Local> = Local::now();
            let bkup = format!("{ORDER_FILE}_{}", now.format("%Y_%m_%d_%H_%M_%S"));
            let mut bkup_path = self.path.clone();
            bkup_path.set_file_name(bkup);

            std::fs::copy(&self.path, bkup_path).into_diagnostic()?;
            std::fs::copy(tmppath, &self.path).into_diagnostic()?;
            println!("{} modlist.txt updated", self.name().bold().blue());
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn load_profile() {
        let profile = Profile::new("./fixtures/profile_newest").expect("This fixture should exist");
        profile.report();
        assert!(!profile.is_empty());
        assert_eq!(profile.len(), 5609);
        assert!(matches!(
            profile.mod_status("Player Character Gestures (OAR)"),
            Status::Enabled
        ));
    }
}
