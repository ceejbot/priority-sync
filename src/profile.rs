use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufWriter, Write};
use std::path::PathBuf;
use std::time::SystemTime;

use chrono::prelude::*;
use miette::{IntoDiagnostic, Result};
use owo_colors::OwoColorize;

static ORDER_FILE: &str = "modlist.txt";
static PRELUDE: &str = "# This file was automatically generated by Mod Organizer.";

pub enum Status {
    Core,
    Enabled,
    Disabled,
}

impl std::fmt::Display for Status {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Status::Core => write!(f, "*"),
            Status::Enabled => write!(f, "+"),
            Status::Disabled => write!(f, "-"),
        }
    }
}

impl From<&str> for Status {
    fn from(v: &str) -> Self {
        if v == "*" {
            Status::Core
        } else if v == "+" {
            Status::Enabled
        } else {
            Status::Disabled
        }
    }
}

/// A representation of a specific profile, recording which mods are mentioned,
/// which are enabled, which are disabled, and what order they're in.
pub struct Profile {
    name: String,
    path: PathBuf,
    priorities: Vec<String>,
    statuses: HashMap<String, Status>,
    modified: SystemTime,
}

impl Profile {
    pub fn from_path(mut path: PathBuf) -> Result<Self> {
        let name = path
            .components()
            .rev()
            .take(1)
            .collect::<PathBuf>()
            .display()
            .to_string();
        path.push(ORDER_FILE);

        let mut statuses = HashMap::new();
        let mut priorities = Vec::new();

        let metadata = std::fs::metadata(&path).into_diagnostic()?;
        let modified = metadata.modified().into_diagnostic()?;
        let file = File::open(&path).into_diagnostic()?;
        let reader = std::io::BufReader::new(file).lines();
        for line in reader.flatten() {
            if line == PRELUDE {
                continue;
            }
            if line.len() < 2 {
                // TODO should be error. We need the enabled signal followed by a mod name.
                continue;
            }
            let (prefix, modname) = line.split_at(1);
            priorities.push(modname.to_string());
            statuses.insert(modname.to_string(), prefix.into());
        }

        let profile = Self {
            name,
            path,
            priorities,
            statuses,
            modified,
        };
        Ok(profile)
    }

    pub fn new(fullpath: &str) -> Result<Self> {
        Profile::from_path(fullpath.into())
    }

    pub fn name(&self) -> &str {
        self.name.as_str()
    }

    pub fn modified(&self) -> SystemTime {
        self.modified
    }

    pub fn modified_human(&self) -> String {
        let dt: DateTime<Local> = self.modified.into();
        chrono_humanize::HumanTime::from(dt).to_string()
    }

    pub fn len(&self) -> usize {
        self.priorities.len()
    }

    pub fn is_empty(&self) -> bool {
        self.priorities.is_empty()
    }

    pub fn mod_status(&self, modname: &str) -> &Status {
        // TODO This is exactly where you would put any attempts to figure out if
        // a mod has been renamed by looking it up in a saved data store of
        // mod names to `modid` or something else in the meta.ini file.
        self.statuses.get(modname).unwrap_or(&Status::Disabled)
    }

    pub fn report(&self) {
        let enabled_count = self.statuses.iter().fold(0, |val, (_k, status)| {
            if matches!(status, Status::Enabled) {
                val + 1
            } else {
                val
            }
        });

        println!(
            "{}:\n    {} mods\n    {} enabled\n    {}",
            self.name.bold().yellow(),
            self.len().bold(),
            enabled_count.bold(),
            self.modified_human().bold()
        );
    }

    pub fn synchronize(&mut self, source: &Profile, force: bool) {
        // This is the case of least work.
        if force || source.priorities.len() >= self.priorities.len() {
            self.priorities = source.priorities.clone();
            return;
        }

        // Here we warn the user and halt rather than deleting mods from its list.
        // This is a design question: we could instead warn the user and halt.
        // Plugins in MO2 avoid this problem because the active profiles always has
        // the full mod list.
        todo!()
    }

    pub fn write(&self) -> Result<()> {
        let now: DateTime<Local> = Local::now();
        let bkup = format!(
            "{ORDER_FILE}_{}",
            now.format("%Y_%m_%d_%H_%M_%S").to_string()
        );
        let mut bkup_path = self.path.clone();
        bkup_path.set_file_name(bkup);

        let tmpfile = tempfile::NamedTempFile::new().into_diagnostic()?;
        {
            let mut fp = BufWriter::new(&tmpfile);
            write!(fp, "{PRELUDE}\r\n").into_diagnostic()?;
            for modname in self.priorities.as_slice() {
                write!(fp, "{}{}\r\n", self.mod_status(modname), modname).into_diagnostic()?;
            }
            fp.flush().into_diagnostic()?;
        }
        let tmppath = tmpfile.into_temp_path();

        std::fs::copy(&self.path, bkup_path).into_diagnostic()?;
        std::fs::copy(tmppath, &self.path).into_diagnostic()?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn load_profile() {
        let profile = Profile::new("./fixtures/profile_1").expect("This fixture should exist");
        profile.report();
        assert!(!profile.is_empty());
        assert_eq!(profile.len(), 5609);
        assert!(matches!(
            profile.mod_status("Player Character Gestures (OAR)"),
            Status::Enabled
        ));
    }
}
